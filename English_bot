import os
import json
import random
import asyncio
from aiogram import Bot, Dispatcher, types
from aiogram.types import InputFile, ReplyKeyboardRemove
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from gtts import gTTS
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# ---------- CONFIG ----------
TOKEN = os.environ.get("TELEGRAM_TOKEN")  # <- ÑÑ‚Ð°Ð²Ð¸Ð¼ Ð² Render ÐºÐ°Ðº Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½ÑƒÑŽ Ð¾ÐºÑ€ÑƒÐ¶ÐµÐ½Ð¸Ñ
if not TOKEN:
    logger.error("TELEGRAM_TOKEN is not set in environment variables.")
    raise SystemExit("Set TELEGRAM_TOKEN environment variable")

WORDS_FILE = "words.json"

# ---------- LOAD / SAVE ----------
if os.path.exists(WORDS_FILE):
    with open(WORDS_FILE, "r", encoding="utf-8") as f:
        words = json.load(f)
else:
    words = {}

def save_words():
    with open(WORDS_FILE, "w", encoding="utf-8") as f:
        json.dump(words, f, ensure_ascii=False, indent=2)

# ---------- BOT INIT ----------
bot = Bot(token=TOKEN)
storage = MemoryStorage()
dp = Dispatcher(storage=storage)

# ---------- FSM ----------
class AddWordState(StatesGroup):
    waiting_for_word = State()

# ---------- Handlers ----------
@dp.message()
async def start_handler(message: types.Message):
    if message.text == "/start":
        await message.answer(
            "ÐŸÑ€Ð¸Ð²ÐµÑ‚! Ð¯ Ð±Ð¾Ñ‚ Ð´Ð»Ñ Ð¸Ð·ÑƒÑ‡ÐµÐ½Ð¸Ñ Ð°Ð½Ð³Ð»Ð¸Ð¹ÑÐºÐ¸Ñ… ÑÐ»Ð¾Ð².\n\n"
            "ÐšÐ¾Ð¼Ð°Ð½Ð´Ñ‹:\n"
            "/add - Ð´Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ ÑÐ»Ð¾Ð²Ð¾\n"
            "/quiz - ÐºÐ²Ð¸Ð· (Ð°Ð½Ð³Ð» â†’ Ñ€ÑƒÑ)\n"
            "/quiz_reverse - ÐºÐ²Ð¸Ð· (Ñ€ÑƒÑ â†’ Ð°Ð½Ð³Ð»)\n"
            "/list - Ð¿Ð¾ÑÐ¼Ð¾Ñ‚Ñ€ÐµÑ‚ÑŒ ÑÐ»Ð¾Ð²Ð°Ñ€ÑŒ"
        )

@dp.message()
async def add_command(message: types.Message, state: FSMContext):
    if message.text == "/add":
        await message.answer("Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ ÑÐ»Ð¾Ð²Ð¾ Ð¸ Ð¿ÐµÑ€ÐµÐ²Ð¾Ð´ Ñ‡ÐµÑ€ÐµÐ· Ð´ÐµÑ„Ð¸Ñ (Ð¿Ñ€Ð¸Ð¼ÐµÑ€: apple-ÑÐ±Ð»Ð¾ÐºÐ¾):")
        await state.set_state(AddWordState.waiting_for_word)

@dp.message(AddWordState.waiting_for_word)
async def receive_word(message: types.Message, state: FSMContext):
    text = message.text.strip()
    if "-" not in text:
        await message.reply("ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚. Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹Ñ‚Ðµ: Ð°Ð½Ð³Ð»Ð¸Ð¹ÑÐºÐ¾Ðµ-Ñ€ÑƒÑÑÐºÐ¸Ð¹")
        return
    eng, rus = text.split("-", 1)
    eng = eng.strip()
    rus = rus.strip()
    if eng in words:
        await message.reply(f"Ð¡Ð»Ð¾Ð²Ð¾ '{eng}' ÑƒÐ¶Ðµ ÐµÑÑ‚ÑŒ. ÐŸÐµÑ€ÐµÐ·Ð°Ð¿Ð¸ÑÑ‹Ð²Ð°ÑŽ Ð¿ÐµÑ€ÐµÐ²Ð¾Ð´.")
    words[eng] = rus
    save_words()
    await message.reply(f"Ð¡Ð»Ð¾Ð²Ð¾ '{eng}' â†’ '{rus}' Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¾!")
    await state.clear()

@dp.message()
async def list_words(message: types.Message):
    if message.text == "/list":
        if not words:
            await message.reply("Ð¡Ð»Ð¾Ð²Ð°Ñ€ÑŒ Ð¿ÑƒÑÑ‚!")
            return
        reply = "\n".join([f"{eng} â†’ {rus}" for eng, rus in words.items()])
        await message.answer(reply)

async def send_quiz(message: types.Message, reverse=False):
    if len(words) < 2:
        await message.answer("Ð”Ð¾Ð±Ð°Ð²ÑŒÑ‚Ðµ Ñ…Ð¾Ñ‚Ñ Ð±Ñ‹ 2 ÑÐ»Ð¾Ð²Ð° Ð´Ð»Ñ ÐºÐ²Ð¸Ð·Ð°!")
        return

    eng = random.choice(list(words.keys()))
    rus = words[eng]

    correct = rus if not reverse else eng
    options = [correct]
    while len(options) < 4:
        w = random.choice(list(words.keys()))
        val = w if reverse else words[w]
        if val not in options:
            options.append(val)
    random.shuffle(options)

    keyboard = types.ReplyKeyboardMarkup(resize_keyboard=True, one_time_keyboard=True)
    for opt in options:
        keyboard.add(opt)

    question = eng if not reverse else rus
    await message.answer(f"Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ð¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ñ‹Ð¹ Ð¿ÐµÑ€ÐµÐ²Ð¾Ð´: {question}", reply_markup=keyboard)

    if not reverse:
        tts = gTTS(text=eng, lang='en')
        tts.save("word.mp3")
        await message.answer_voice(InputFile("word.mp3"))
        os.remove("word.mp3")

@dp.message()
async def quiz_handler(message: types.Message):
    if message.text == "/quiz":
        await send_quiz(message, reverse=False)
    elif message.text == "/quiz_reverse":
        await send_quiz(message, reverse=True)

@dp.message()
async def check_answer(message: types.Message):
    text = message.text.strip()
    for eng, rus in words.items():
        if text == eng or text == rus:
            await message.answer(f"Ð’ÐµÑ€Ð½Ð¾! '{eng}' â†’ '{rus}'", reply_markup=ReplyKeyboardRemove())
            return
    if text.startswith("/"):
        return
    await message.answer("ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ð¾ ðŸ˜• ÐŸÐ¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹ ÐµÑ‰Ñ‘ Ñ€Ð°Ð·!")

# ---------- RUN ----------
async def main():
    logger.info("Starting bot...")
    await dp.start_polling(bot)

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except (KeyboardInterrupt, SystemExit):
        logger.info("Bot stopped")
